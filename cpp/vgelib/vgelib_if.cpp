
// Autogenerated file - do not edit!
#include "vgelib/vgelib.hpp"

using namespace vge;

extern "C" {
DLLEXPORT Exception * AddDynamicDescriptors(Application* app);
DLLEXPORT Exception * AddValidation(Application* app);
DLLEXPORT Exception * AddValidationException(int32_t msgId);
DLLEXPORT Exception * Allocator_AllocBuffer(Allocator* allocator, int32_t usage, uint64_t size, void *& hBuffer, uint32_t& memType, uint32_t& alignment);
DLLEXPORT Exception * Allocator_AllocDeviceBuffer(Allocator* allocator, int32_t usage, uint64_t size, void *& hBuffer, uint32_t& memType, uint32_t& alignment);
DLLEXPORT Exception * Allocator_AllocImage(Allocator* allocator, int32_t usage, ImageDescription* im, void *& hImage, uint64_t& size, uint32_t& memType, uint32_t& alignment);
DLLEXPORT Exception * Allocator_AllocMemory(Allocator* allocator, uint64_t size, uint32_t memType, bool hostMemory, void *& hMem, void *& memPtr);
DLLEXPORT Exception * Allocator_AllocView(Allocator* allocator, void * hImage, ImageRange* rg, ImageDescription* im, bool cube, void *& hView);
DLLEXPORT Exception * Allocator_BindBuffer(Allocator* allocator, void * hMem, void * hBuffer, uint64_t offset);
DLLEXPORT Exception * Allocator_BindImage(Allocator* allocator, void * hMem, void * hBuffer, uint64_t offset);
DLLEXPORT Exception * Allocator_FreeBuffer(Allocator* allocator, void * hBuffer);
DLLEXPORT Exception * Allocator_FreeImage(Allocator* allocator, void * hImage);
DLLEXPORT Exception * Allocator_FreeMemory(Allocator* allocator, void * hMem, bool hostMemory);
DLLEXPORT Exception * Allocator_FreeView(Allocator* allocator, void * hView);
DLLEXPORT Exception * Application_Init(Application* app, Instance*& inst);
DLLEXPORT Exception * Buffer_CopyFrom(Buffer* buffer, uint64_t offset, void * ptr, uint64_t size);
DLLEXPORT Exception * Buffer_GetPtr(Buffer* buffer, void *& ptr);
DLLEXPORT Exception * Buffer_NewView(Buffer* buffer, int32_t format, uint64_t offset, uint64_t size, BufferView*& view);
DLLEXPORT Exception * Command_Begin(Command* cmd);
DLLEXPORT Exception * Command_BeginRenderPass(Command* cmd, RenderPass* rp, Framebuffer* fb);
DLLEXPORT Exception * Command_ClearImage(Command* cmd, Image* dst, ImageRange* imRange, int32_t layout, float color, float alpha);
DLLEXPORT Exception * Command_Compute(Command* hCmd, ComputePipeline* hPl, uint32_t x, uint32_t y, uint32_t z, DescriptorSet** descriptors, size_t descriptors_len);
DLLEXPORT Exception * Command_CopyBuffer(Command* cmd, Buffer* src, Buffer* dst);
DLLEXPORT Exception * Command_CopyBufferToImage(Command* cmd, Buffer* src, Image* dst, ImageRange* imRange, uint64_t offset);
DLLEXPORT Exception * Command_CopyImageToBuffer(Command* cmd, Image* src, Buffer* dst, ImageRange* imRange, uint64_t offset);
DLLEXPORT Exception * Command_Draw(Command* cmd, DrawItem* draws, size_t draws_len, uint8_t* pushConstants, size_t pushConstants_len);
DLLEXPORT Exception * Command_EndRenderPass(Command* cmd);
DLLEXPORT Exception * Command_SetLayout(Command* cmd, Image* image, ImageRange* imRange, int32_t newLayout);
DLLEXPORT Exception * Command_Transfer(Command* cmd, TransferItem* transfer, size_t transfer_len);
DLLEXPORT Exception * Command_Wait(Command* cmd);
DLLEXPORT Exception * Command_WriteTimer(Command* cmd, QueryPool* qp, int32_t stages, uint32_t timerIndex);
DLLEXPORT Exception * ComputePipeline_Create(ComputePipeline* cp);
DLLEXPORT void DebugPoint(char * point, size_t point_len);
DLLEXPORT Exception * DescriptorLayout_NewPool(DescriptorLayout* layout, uint32_t size, DescriptorPool*& pool);
DLLEXPORT Exception * DescriptorPool_Alloc(DescriptorPool* pool, DescriptorSet*& ds);
DLLEXPORT Exception * DescriptorSet_WriteBuffer(DescriptorSet* ds, uint32_t binding, uint32_t at, Buffer* buffer, uint64_t from, uint64_t size);
DLLEXPORT Exception * DescriptorSet_WriteBufferView(DescriptorSet* ds, uint32_t binding, uint32_t at, BufferView* bufferView);
DLLEXPORT Exception * DescriptorSet_WriteDSImageView(DescriptorSet* ds, uint32_t binding, uint32_t at, void * view, int32_t layout, Sampler* sampler);
DLLEXPORT Exception * DescriptorSet_WriteDSSlice(DescriptorSet* ds, uint32_t binding, uint32_t at, void * buffer, uint64_t from, uint64_t size);
DLLEXPORT Exception * DescriptorSet_WriteImage(DescriptorSet* ds, uint32_t binding, uint32_t at, ImageView* view, Sampler* sampler);
DLLEXPORT Exception * Desktop_CreateWindow(Desktop* desktop, char * title, size_t title_len, WindowPos* pos, Window*& win);
DLLEXPORT Exception * Desktop_GetClipboard(Desktop* desktop, uint64_t& textLen, uint8_t* text, size_t text_len);
DLLEXPORT Exception * Desktop_GetKeyName(Desktop* desktop, uint32_t keyCode, uint8_t* name, size_t name_len, uint32_t& strLen);
DLLEXPORT Exception * Desktop_GetMonitor(Desktop* desktop, uint32_t monitor, WindowPos* info);
DLLEXPORT Exception * Desktop_PullEvent(Desktop* desktop, RawEvent* ev);
DLLEXPORT Exception * Desktop_SetClipboard(Desktop* desktop, uint8_t* text, size_t text_len);
DLLEXPORT Exception * Device_NewAllocator(Device* dev, Allocator*& allocator);
DLLEXPORT Exception * Device_NewBuffer(Device* dev, uint64_t size, bool hostMemory, int32_t usage, Buffer*& buffer, void *& rawBuffer);
DLLEXPORT Exception * Device_NewCommand(Device* dev, int32_t queueType, bool once, Command*& command);
DLLEXPORT Exception * Device_NewComputePipeline(Device* dev, ComputePipeline*& cp);
DLLEXPORT Exception * Device_NewDescriptorLayout(Device* dev, int32_t descriptorType, int32_t stages, uint32_t element, int32_t flags, DescriptorLayout* prevLayout, DescriptorLayout*& dsLayout);
DLLEXPORT Exception * Device_NewGlslCompiler(Device* dev, GlslCompiler*& comp);
DLLEXPORT Exception * Device_NewGraphicsPipeline(Device* dev, GraphicsPipeline*& gp);
DLLEXPORT Exception * Device_NewImage(Device* dev, int32_t usage, ImageDescription* desc, Image*& image, void *& rawImage);
DLLEXPORT Exception * Device_NewMemoryBlock(Device* dev, MemoryBlock*& memBlock);
DLLEXPORT Exception * Device_NewSampler(Device* dev, int32_t repeatMode, Sampler*& sampler);
DLLEXPORT Exception * Device_NewTimestampQuery(Device* dev, uint32_t size, QueryPool*& qp);
DLLEXPORT Exception * Device_Submit(Device* dev, Command* cmd, uint32_t priority, SubmitInfo** info, size_t info_len, int32_t waitStage, SubmitInfo*& waitInfo);
DLLEXPORT void Disposable_Dispose(Disposable* disp);
DLLEXPORT void Exception_GetError(Exception* ex, char * msg, size_t msg_len, int32_t& msgLen);
DLLEXPORT Exception * GlslCompiler_Compile(GlslCompiler* comp, int32_t stage, uint8_t* src, size_t src_len, void *& instance);
DLLEXPORT Exception * GlslCompiler_Free(GlslCompiler* comp, void * instance);
DLLEXPORT Exception * GlslCompiler_GetOutput(GlslCompiler* comp, void * instance, void *& msg, uint64_t& msg_len, uint32_t& result);
DLLEXPORT Exception * GlslCompiler_GetSpirv(GlslCompiler* comp, void * instance, void *& spirv, uint64_t& spirv_len);
DLLEXPORT Exception * GraphicsPipeline_AddAlphaBlend(GraphicsPipeline* pl);
DLLEXPORT Exception * GraphicsPipeline_AddDepth(GraphicsPipeline* pl, bool write, bool check);
DLLEXPORT Exception * GraphicsPipeline_AddVertexBinding(GraphicsPipeline* pl, uint32_t stride, int32_t rate);
DLLEXPORT Exception * GraphicsPipeline_AddVertexFormat(GraphicsPipeline* pl, int32_t format, uint32_t offset);
DLLEXPORT Exception * GraphicsPipeline_Create(GraphicsPipeline* pipeline, RenderPass* renderPass);
DLLEXPORT Exception * GraphicsPipeline_SetTopology(GraphicsPipeline* pl, int32_t topology);
DLLEXPORT Exception * ImageLoader_Describe(ImageLoader* loader, char * kind, size_t kind_len, ImageDescription* desc, uint8_t* content, size_t content_len);
DLLEXPORT Exception * ImageLoader_Load(ImageLoader* loader, char * kind, size_t kind_len, uint8_t* content, size_t content_len, Buffer* buf);
DLLEXPORT Exception * ImageLoader_Save(ImageLoader* loader, char * kind, size_t kind_len, ImageDescription* desc, Buffer* buf, uint8_t* content, size_t content_len, uint64_t& reqSize);
DLLEXPORT Exception * ImageLoader_Supported(ImageLoader* loader, char * kind, size_t kind_len, bool& read, bool& write);
DLLEXPORT Exception * Image_NewView(Image* image, ImageRange* imRange, ImageView*& imageView, void *& rawView, bool cube);
DLLEXPORT Exception * Instance_GetPhysicalDevice(Instance* instance, int32_t index, DeviceInfo* info);
DLLEXPORT Exception * Instance_NewDevice(Instance* instance, int32_t index, Device*& pd);
DLLEXPORT Exception * MemoryBlock_Allocate(MemoryBlock* memBlock);
DLLEXPORT Exception * MemoryBlock_Reserve(MemoryBlock* memBlock, MemoryObject* memObject, bool& suitable);
DLLEXPORT Exception * NewApplication(char * name, size_t name_len, Application*& app);
DLLEXPORT Exception * NewDesktop(Application* app, int32_t imageUsage, Desktop*& desktop);
DLLEXPORT Exception * NewImageLoader(ImageLoader*& loader);
DLLEXPORT Exception * NewRenderPass(Device* dev, RenderPass*& rp, bool depthAttachment, AttachmentInfo* attachments, size_t attachments_len);
DLLEXPORT Exception * Pipeline_AddDescriptorLayout(Pipeline* pl, DescriptorLayout* dsLayout);
DLLEXPORT Exception * Pipeline_AddPushConstants(Pipeline* pl, uint32_t size, int32_t stages);
DLLEXPORT Exception * Pipeline_AddShader(Pipeline* pl, int32_t stage, uint8_t* code, size_t code_len);
DLLEXPORT Exception * QueryPool_Get(QueryPool* qp, uint64_t* values, size_t values_len, float& timestampPeriod);
DLLEXPORT Exception * RenderPass_NewFrameBuffer(RenderPass* rp, ImageView** attachments, size_t attachments_len, Framebuffer*& fb);
DLLEXPORT Exception * RenderPass_NewFrameBuffer2(RenderPass* rp, uint32_t width, uint32_t height, void ** attachments, size_t attachments_len, Framebuffer*& fb);
DLLEXPORT Exception * RenderPass_NewNullFrameBuffer(RenderPass* rp, uint32_t width, uint32_t height, Framebuffer*& fb);
DLLEXPORT Exception * Window_GetNextFrame(Window* win, Image*& image, SubmitInfo*& submitInfo, int32_t& viewIndex);
DLLEXPORT Exception * Window_GetPos(Window* win, WindowPos* pos);
DLLEXPORT Exception * Window_PrepareSwapchain(Window* win, Device* dev, ImageDescription* imageDesc, int32_t& imageCount);
DLLEXPORT Exception * Window_SetPos(Window* win, WindowPos* pos);
}

// Implementation

Exception * AddDynamicDescriptors(Application* app) {
    try {
        Static::AddDynamicDescriptors (app);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * AddValidation(Application* app) {
    try {
        Static::AddValidation (app);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * AddValidationException(int32_t msgId) {
    try {
        Static::AddValidationException (msgId);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * Allocator_AllocBuffer(Allocator* allocator, int32_t usage, uint64_t size, void *& hBuffer, uint32_t& memType, uint32_t& alignment) {
    try {
        allocator->AllocBuffer(vk::BufferUsageFlags(usage), size, hBuffer, memType, alignment);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * Allocator_AllocDeviceBuffer(Allocator* allocator, int32_t usage, uint64_t size, void *& hBuffer, uint32_t& memType, uint32_t& alignment) {
    try {
        allocator->AllocDeviceBuffer(vk::BufferUsageFlags(usage), size, hBuffer, memType, alignment);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * Allocator_AllocImage(Allocator* allocator, int32_t usage, ImageDescription* im, void *& hImage, uint64_t& size, uint32_t& memType, uint32_t& alignment) {
    try {
        allocator->AllocImage(vk::ImageUsageFlags(usage), im, hImage, size, memType, alignment);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * Allocator_AllocMemory(Allocator* allocator, uint64_t size, uint32_t memType, bool hostMemory, void *& hMem, void *& memPtr) {
    try {
        allocator->AllocMemory(size, memType, hostMemory, hMem, memPtr);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * Allocator_AllocView(Allocator* allocator, void * hImage, ImageRange* rg, ImageDescription* im, bool cube, void *& hView) {
    try {
        allocator->AllocView(hImage, rg, im, cube, hView);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * Allocator_BindBuffer(Allocator* allocator, void * hMem, void * hBuffer, uint64_t offset) {
    try {
        allocator->BindBuffer(hMem, hBuffer, offset);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * Allocator_BindImage(Allocator* allocator, void * hMem, void * hBuffer, uint64_t offset) {
    try {
        allocator->BindImage(hMem, hBuffer, offset);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * Allocator_FreeBuffer(Allocator* allocator, void * hBuffer) {
    try {
        allocator->FreeBuffer(hBuffer);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * Allocator_FreeImage(Allocator* allocator, void * hImage) {
    try {
        allocator->FreeImage(hImage);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * Allocator_FreeMemory(Allocator* allocator, void * hMem, bool hostMemory) {
    try {
        allocator->FreeMemory(hMem, hostMemory);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * Allocator_FreeView(Allocator* allocator, void * hView) {
    try {
        allocator->FreeView(hView);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * Application_Init(Application* app, Instance*& inst) {
    try {
        app->Init(inst);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * Buffer_CopyFrom(Buffer* buffer, uint64_t offset, void * ptr, uint64_t size) {
    try {
        buffer->CopyFrom(offset, ptr, size);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * Buffer_GetPtr(Buffer* buffer, void *& ptr) {
    try {
        buffer->GetPtr(ptr);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * Buffer_NewView(Buffer* buffer, int32_t format, uint64_t offset, uint64_t size, BufferView*& view) {
    try {
        buffer->NewView(vk::Format(format), offset, size, view);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * Command_Begin(Command* cmd) {
    try {
        cmd->Begin();
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * Command_BeginRenderPass(Command* cmd, RenderPass* rp, Framebuffer* fb) {
    try {
        cmd->BeginRenderPass(rp, fb);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * Command_ClearImage(Command* cmd, Image* dst, ImageRange* imRange, int32_t layout, float color, float alpha) {
    try {
        cmd->ClearImage(dst, imRange, vk::ImageLayout(layout), color, alpha);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * Command_Compute(Command* hCmd, ComputePipeline* hPl, uint32_t x, uint32_t y, uint32_t z, DescriptorSet** descriptors, size_t descriptors_len) {
    try {
        hCmd->Compute(hPl, x, y, z, descriptors, descriptors_len);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * Command_CopyBuffer(Command* cmd, Buffer* src, Buffer* dst) {
    try {
        cmd->CopyBuffer(src, dst);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * Command_CopyBufferToImage(Command* cmd, Buffer* src, Image* dst, ImageRange* imRange, uint64_t offset) {
    try {
        cmd->CopyBufferToImage(src, dst, imRange, offset);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * Command_CopyImageToBuffer(Command* cmd, Image* src, Buffer* dst, ImageRange* imRange, uint64_t offset) {
    try {
        cmd->CopyImageToBuffer(src, dst, imRange, offset);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * Command_Draw(Command* cmd, DrawItem* draws, size_t draws_len, uint8_t* pushConstants, size_t pushConstants_len) {
    try {
        cmd->Draw(draws, draws_len, pushConstants, pushConstants_len);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * Command_EndRenderPass(Command* cmd) {
    try {
        cmd->EndRenderPass();
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * Command_SetLayout(Command* cmd, Image* image, ImageRange* imRange, int32_t newLayout) {
    try {
        cmd->SetLayout(image, imRange, vk::ImageLayout(newLayout));
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * Command_Transfer(Command* cmd, TransferItem* transfer, size_t transfer_len) {
    try {
        cmd->Transfer(transfer, transfer_len);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * Command_Wait(Command* cmd) {
    try {
        cmd->Wait();
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * Command_WriteTimer(Command* cmd, QueryPool* qp, int32_t stages, uint32_t timerIndex) {
    try {
        cmd->WriteTimer(qp, vk::PipelineStageFlags(stages), timerIndex);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * ComputePipeline_Create(ComputePipeline* cp) {
    try {
        cp->Create();
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

void DebugPoint(char * point, size_t point_len) {
        Static::DebugPoint (point, point_len);
}

Exception * DescriptorLayout_NewPool(DescriptorLayout* layout, uint32_t size, DescriptorPool*& pool) {
    try {
        layout->NewPool(size, pool);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * DescriptorPool_Alloc(DescriptorPool* pool, DescriptorSet*& ds) {
    try {
        pool->Alloc(ds);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * DescriptorSet_WriteBuffer(DescriptorSet* ds, uint32_t binding, uint32_t at, Buffer* buffer, uint64_t from, uint64_t size) {
    try {
        ds->WriteBuffer(binding, at, buffer, from, size);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * DescriptorSet_WriteBufferView(DescriptorSet* ds, uint32_t binding, uint32_t at, BufferView* bufferView) {
    try {
        ds->WriteBufferView(binding, at, bufferView);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * DescriptorSet_WriteDSImageView(DescriptorSet* ds, uint32_t binding, uint32_t at, void * view, int32_t layout, Sampler* sampler) {
    try {
        ds->WriteDSImageView(binding, at, view, vk::ImageLayout(layout), sampler);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * DescriptorSet_WriteDSSlice(DescriptorSet* ds, uint32_t binding, uint32_t at, void * buffer, uint64_t from, uint64_t size) {
    try {
        ds->WriteDSSlice(binding, at, buffer, from, size);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * DescriptorSet_WriteImage(DescriptorSet* ds, uint32_t binding, uint32_t at, ImageView* view, Sampler* sampler) {
    try {
        ds->WriteImage(binding, at, view, sampler);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * Desktop_CreateWindow(Desktop* desktop, char * title, size_t title_len, WindowPos* pos, Window*& win) {
    try {
        desktop->CreateWindow(title, title_len, pos, win);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * Desktop_GetClipboard(Desktop* desktop, uint64_t& textLen, uint8_t* text, size_t text_len) {
    try {
        desktop->GetClipboard(textLen, text, text_len);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * Desktop_GetKeyName(Desktop* desktop, uint32_t keyCode, uint8_t* name, size_t name_len, uint32_t& strLen) {
    try {
        desktop->GetKeyName(keyCode, name, name_len, strLen);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * Desktop_GetMonitor(Desktop* desktop, uint32_t monitor, WindowPos* info) {
    try {
        desktop->GetMonitor(monitor, info);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * Desktop_PullEvent(Desktop* desktop, RawEvent* ev) {
    try {
        desktop->PullEvent(ev);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * Desktop_SetClipboard(Desktop* desktop, uint8_t* text, size_t text_len) {
    try {
        desktop->SetClipboard(text, text_len);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * Device_NewAllocator(Device* dev, Allocator*& allocator) {
    try {
        dev->NewAllocator(allocator);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * Device_NewBuffer(Device* dev, uint64_t size, bool hostMemory, int32_t usage, Buffer*& buffer, void *& rawBuffer) {
    try {
        dev->NewBuffer(size, hostMemory, vk::BufferUsageFlags(usage), buffer, rawBuffer);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * Device_NewCommand(Device* dev, int32_t queueType, bool once, Command*& command) {
    try {
        dev->NewCommand(vk::QueueFlags(queueType), once, command);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * Device_NewComputePipeline(Device* dev, ComputePipeline*& cp) {
    try {
        dev->NewComputePipeline(cp);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * Device_NewDescriptorLayout(Device* dev, int32_t descriptorType, int32_t stages, uint32_t element, int32_t flags, DescriptorLayout* prevLayout, DescriptorLayout*& dsLayout) {
    try {
        dev->NewDescriptorLayout(vk::DescriptorType(descriptorType), vk::ShaderStageFlags(stages), element, vk::DescriptorBindingFlagBitsEXT(flags), prevLayout, dsLayout);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * Device_NewGlslCompiler(Device* dev, GlslCompiler*& comp) {
    try {
        dev->NewGlslCompiler(comp);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * Device_NewGraphicsPipeline(Device* dev, GraphicsPipeline*& gp) {
    try {
        dev->NewGraphicsPipeline(gp);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * Device_NewImage(Device* dev, int32_t usage, ImageDescription* desc, Image*& image, void *& rawImage) {
    try {
        dev->NewImage(vk::ImageUsageFlags(usage), desc, image, rawImage);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * Device_NewMemoryBlock(Device* dev, MemoryBlock*& memBlock) {
    try {
        dev->NewMemoryBlock(memBlock);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * Device_NewSampler(Device* dev, int32_t repeatMode, Sampler*& sampler) {
    try {
        dev->NewSampler(vk::SamplerAddressMode(repeatMode), sampler);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * Device_NewTimestampQuery(Device* dev, uint32_t size, QueryPool*& qp) {
    try {
        dev->NewTimestampQuery(size, qp);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * Device_Submit(Device* dev, Command* cmd, uint32_t priority, SubmitInfo** info, size_t info_len, int32_t waitStage, SubmitInfo*& waitInfo) {
    try {
        dev->Submit(cmd, priority, info, info_len, vk::PipelineStageFlags(waitStage), waitInfo);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

void Disposable_Dispose(Disposable* disp) {
        disp->Dispose();
}

void Exception_GetError(Exception* ex, char * msg, size_t msg_len, int32_t& msgLen) {
        ex->GetError(msg, msg_len, msgLen);
}

Exception * GlslCompiler_Compile(GlslCompiler* comp, int32_t stage, uint8_t* src, size_t src_len, void *& instance) {
    try {
        comp->Compile(vk::ShaderStageFlags(stage), src, src_len, instance);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * GlslCompiler_Free(GlslCompiler* comp, void * instance) {
    try {
        comp->Free(instance);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * GlslCompiler_GetOutput(GlslCompiler* comp, void * instance, void *& msg, uint64_t& msg_len, uint32_t& result) {
    try {
        comp->GetOutput(instance, msg, msg_len, result);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * GlslCompiler_GetSpirv(GlslCompiler* comp, void * instance, void *& spirv, uint64_t& spirv_len) {
    try {
        comp->GetSpirv(instance, spirv, spirv_len);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * GraphicsPipeline_AddAlphaBlend(GraphicsPipeline* pl) {
    try {
        pl->AddAlphaBlend();
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * GraphicsPipeline_AddDepth(GraphicsPipeline* pl, bool write, bool check) {
    try {
        pl->AddDepth(write, check);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * GraphicsPipeline_AddVertexBinding(GraphicsPipeline* pl, uint32_t stride, int32_t rate) {
    try {
        pl->AddVertexBinding(stride, vk::VertexInputRate(rate));
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * GraphicsPipeline_AddVertexFormat(GraphicsPipeline* pl, int32_t format, uint32_t offset) {
    try {
        pl->AddVertexFormat(vk::Format(format), offset);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * GraphicsPipeline_Create(GraphicsPipeline* pipeline, RenderPass* renderPass) {
    try {
        pipeline->Create(renderPass);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * GraphicsPipeline_SetTopology(GraphicsPipeline* pl, int32_t topology) {
    try {
        pl->SetTopology(vk::PrimitiveTopology(topology));
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * ImageLoader_Describe(ImageLoader* loader, char * kind, size_t kind_len, ImageDescription* desc, uint8_t* content, size_t content_len) {
    try {
        loader->Describe(kind, kind_len, desc, content, content_len);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * ImageLoader_Load(ImageLoader* loader, char * kind, size_t kind_len, uint8_t* content, size_t content_len, Buffer* buf) {
    try {
        loader->Load(kind, kind_len, content, content_len, buf);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * ImageLoader_Save(ImageLoader* loader, char * kind, size_t kind_len, ImageDescription* desc, Buffer* buf, uint8_t* content, size_t content_len, uint64_t& reqSize) {
    try {
        loader->Save(kind, kind_len, desc, buf, content, content_len, reqSize);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * ImageLoader_Supported(ImageLoader* loader, char * kind, size_t kind_len, bool& read, bool& write) {
    try {
        loader->Supported(kind, kind_len, read, write);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * Image_NewView(Image* image, ImageRange* imRange, ImageView*& imageView, void *& rawView, bool cube) {
    try {
        image->NewView(imRange, imageView, rawView, cube);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * Instance_GetPhysicalDevice(Instance* instance, int32_t index, DeviceInfo* info) {
    try {
        instance->GetPhysicalDevice(index, info);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * Instance_NewDevice(Instance* instance, int32_t index, Device*& pd) {
    try {
        instance->NewDevice(index, pd);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * MemoryBlock_Allocate(MemoryBlock* memBlock) {
    try {
        memBlock->Allocate();
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * MemoryBlock_Reserve(MemoryBlock* memBlock, MemoryObject* memObject, bool& suitable) {
    try {
        memBlock->Reserve(memObject, suitable);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * NewApplication(char * name, size_t name_len, Application*& app) {
    try {
        Static::NewApplication (name, name_len, app);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * NewDesktop(Application* app, int32_t imageUsage, Desktop*& desktop) {
    try {
        Static::NewDesktop (app, vk::ImageUsageFlags(imageUsage), desktop);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * NewImageLoader(ImageLoader*& loader) {
    try {
        Static::NewImageLoader (loader);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * NewRenderPass(Device* dev, RenderPass*& rp, bool depthAttachment, AttachmentInfo* attachments, size_t attachments_len) {
    try {
        Static::NewRenderPass (dev, rp, depthAttachment, attachments, attachments_len);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * Pipeline_AddDescriptorLayout(Pipeline* pl, DescriptorLayout* dsLayout) {
    try {
        pl->AddDescriptorLayout(dsLayout);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * Pipeline_AddPushConstants(Pipeline* pl, uint32_t size, int32_t stages) {
    try {
        pl->AddPushConstants(size, vk::ShaderStageFlags(stages));
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * Pipeline_AddShader(Pipeline* pl, int32_t stage, uint8_t* code, size_t code_len) {
    try {
        pl->AddShader(vk::ShaderStageFlags(stage), code, code_len);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * QueryPool_Get(QueryPool* qp, uint64_t* values, size_t values_len, float& timestampPeriod) {
    try {
        qp->Get(values, values_len, timestampPeriod);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * RenderPass_NewFrameBuffer(RenderPass* rp, ImageView** attachments, size_t attachments_len, Framebuffer*& fb) {
    try {
        rp->NewFrameBuffer(attachments, attachments_len, fb);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * RenderPass_NewFrameBuffer2(RenderPass* rp, uint32_t width, uint32_t height, void ** attachments, size_t attachments_len, Framebuffer*& fb) {
    try {
        rp->NewFrameBuffer2(width, height, attachments, attachments_len, fb);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * RenderPass_NewNullFrameBuffer(RenderPass* rp, uint32_t width, uint32_t height, Framebuffer*& fb) {
    try {
        rp->NewNullFrameBuffer(width, height, fb);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * Window_GetNextFrame(Window* win, Image*& image, SubmitInfo*& submitInfo, int32_t& viewIndex) {
    try {
        win->GetNextFrame(image, submitInfo, viewIndex);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * Window_GetPos(Window* win, WindowPos* pos) {
    try {
        win->GetPos(pos);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * Window_PrepareSwapchain(Window* win, Device* dev, ImageDescription* imageDesc, int32_t& imageCount) {
    try {
        win->PrepareSwapchain(dev, imageDesc, imageCount);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

Exception * Window_SetPos(Window* win, WindowPos* pos) {
    try {
        win->SetPos(pos);
    } catch (const std::exception &ex) {
        return new Exception(ex);
    }
    return Exception::getValidationError();
}

